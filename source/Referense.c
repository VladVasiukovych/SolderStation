/*
* Referense.c
*
* Created: 22.02.2017 15:36:08
*  Author: VLAD
*/

#include "Referense.h"

/*инициализация*/
void Referense(void)
{
	/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*/	//Порты
	//конфигурация порта на (0 вход) (1 выход)
	DDRA = (1<<PA7)|(1<<PA6)|(1<<PA5)|(1<<PA4)|		//LCD
	(0<<PA3)|		//SolderSW1 (тумблер вверх)
	(0<<PA2)|		//CurrentSense
	(0<<PA1)|		//FanSet
	(0<<PA0);		//SolderTemp
	PORTA = (0<<PA7)|(0<<PA6)|(0<<PA5)|(0<<PA4)|	//LCD
	(1<<PA3)|		//SolderSW1 (тумблер вверх)
	(0<<PA2)|		//CurrentSense
	(0<<PA1)|		//FanSet
	(0<<PA0);		//SolderTemp
	
	DDRD = (1<<PD7)|	//Fan_PWM
	(0<<PD6)|			//Enc2Button
	(1<<PD5)|			//OC1A
	(1<<PD4)|			//OC1B
	(0<<PD3)|			//Enc1Button
	(0<<PD2)|			//INT0
	(0<<PD1)|			//TX
	(0<<PD0);			//RX
	PORTA = (0<<PD7)|
	(1<<PD6)|			//Enc2Button
	(0<<PD5)|			//OC1A
	(0<<PD4)|			//OC1B
	(1<<PD3)|			//Enc1Button
	(0<<PD2)|			//INT0
	(0<<PD1)|			//TX
	(0<<PD0);			//RX
	
	
	DDRC =	(1<<PC7)|	//RS
	(1<<PC6)|			//RW
	(1<<PC5)|			//EN
	(1<<PC4)|			//Relay
	(0<<PC3)|			//Enc2B
	(0<<PC2)|			//Enc2A
	(0<<PC1)|			//Enc1B
	(0<<PC0);			//Enc1A
	PORTC = (0<<PC7)|	//RS
	(0<<PC6)|			//RW
	(0<<PC5)|			//EN
	(0<<PC4)|			//Relay
	(1<<PC3)|			//Enc2B
	(1<<PC2)|			//Enc2A
	(1<<PC1)|			//Enc1B
	(1<<PC0);			//Enc1A

	DDRB =  (1<<PB7)|	//SCK
	(0<<PB6)|			//MISO
	(1<<PB5)|			//MOSI
	(1<<PB4)|			//SS
	(0<<PB3)|			//FanSW2
	(0<<PB2)|			//FanSW1
	(0<<PB1)|			//T1
	(0<<PB0);			//SolderSW2
	PORTB = (1<<PB7)|	//SCK
	(0<<PB6)|			//MISO
	(0<<PB5)|			//MOSI
	(0<<PB4)|			//SS
	(1<<PB3)|			//FanSW2
	(1<<PB2)|			//FanSW1
	(0<<PB1)|			//T1
	(1<<PB0);			//SolderSW2
	/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*/	//UART
	UBRRH=0;
	UBRRL=51;								//скорость обмена 9600 бод (51)
	//0D-\n =новая сторка
	//0A-\r = возрат каретки
	//-----------------------------------------------------------------------------------------------------------
	UCSRB =
	(1<<RXCIE)|		//разрешение прерывания приёма данных
	(0<<TXCIE)|		//разрешение прерывания завершения передачи
	(0<<UDRIE)|		//разрешение прерывания отсутствия данных для передачи
	(1<<RXEN)|		//разрешение приёма данных
	(1<<TXEN)|		//разрешение передачи данных
	(0<<UCSZ2)|		//размер слова (8 бит)
	(0<<RXB8)|		//8 й разряд принимаемых данных. При использовании 9 разрядных слов данных этот разряд содержит значение старшего разряда принятого слова. В случае USART содержимое этого разряда должно быть считано до прочтения регистра данных UDR.
	(0<<TXB8);		//8 й разряд передаваемых данных. При использовании 9 разрядных слов данных, содержимое этого разряда является старшим разрядом передаваемого слова. Требуемое значение должно быть занесено в этот разряд до загрузки байта данных в регистр UDR.
	//-----------------------------------------------------------------------------------------------------------
	UCSRC =					//Control and Status Register
	(1<<URSEL)|				//выбор регистра между UBRRH и UBRRL (должно быть 1)
	(0<<UMSEL)|				//асинхронный режим работы
	(0<<UPM1)|(0<<UPM0)|	//режим  четности (нет контроля)
	(0<<USBS)|				//количество стоп-битов (1 бит)
	(1<<UCSZ1)|(1<<UCSZ0)|	//размер слова (8 бит)
	(0<<UCPOL);				//USART Clock POLarity (0-данные отправляются по переднему фронту 1-по заднему фронту)
	/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*/	//SPI
	SPCR =
	(0<<SPIE)|				//Разрешение прерываний от SPI
	(1<<SPE)|				//Включение модуля SPI
	(0<<DORD)|				//Порядок передачи данных (1 - младшим битом вперёд, 0 - старшим битом вперёд)
	(1<<MSTR)|				//Режим работы МК (1 - режим master)
	(0<<CPOL)|				//Полярность тактового сигнала (1 - тактовый сигнал начинается с уровня логической единицы, 0 - с уровня логического нуля)
	(0<<CPHA)|				//Фаза тактового сигнала (1 - защелкивание данных выполняется по падающему фронту, 0 - защелкивание данных выполняется по нарастающему фронту)
	(0<<SPR1)|(1<<SPR0);	//Частота тактового сигнала SPI /16 (00-/4, 01-/16, )
	//-----------------------------------------------------------------------------------------------------------
	SPSR =					//Статусный регистр
	(0<<SPIF)|				//Флаг прерывания от SPI
	(0<<WCOL)|				//Флаг конфликта записи. Флаг устанавливается в 1, если во время передачи данных выполняется попытка записи в регистр данных SPDR. Флаг сбрасывается аппаратно после чтения регистра SPSR с последующим обращением к регистру данных SPDR.
	(0<<SPI2X);				//Бит удвоения скорости обмена тактового сигнала SPI
	/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*/	//АЦП
	ADCSRA =
	(1<<ADEN)|			//Включить ацп
	(1<<ADSC)|			//Запуск преобразование 1-старт. После преобразования сбрасывается в ноль аппаратно.
	(1<<ADATE)|			//Выбор работы АЦП. 1-непрерывный 0-по запуску ADSC
	(0<<ADIF)|			//Флаг прерывания
	(1<<ADIE)|			//Разрешение прерывания
	(1<<ADPS2)|(1<<ADPS1)|(0<<ADPS0);	//делитель частоты на 64
	//-----------------------------------------------------------------------------------------------------------
	ADMUX =
	(0<<REFS1)|(0<<REFS0)|						//опорный источник питания (00 - питание от AREF) (01 - от AVCC, к AREF конденсатор)
	(0<<ADLAR)|									//выравнивание результата по правой границе - 0, по левой границе - 1
	(0<<MUX4)|(0<<MUX3)|(0<<MUX2)|(0<<MUX1)|(0<<MUX0);	//вход ацп
	/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*/	//Таймер0
	TCCR0 =
	(0<<FOC0)|						//принудительное изменение вывода OC0 (работает только для режимов  Normal и CTC)
	(0<<WGM01)|(0<<WGM00)|			//режим работы таймера счетчика (Normal)
	(0<<COM01)|(0<<COM00)|			//поведение вывода OC0 (вывод отключен)
	(0<<CS02)|(1<<CS01)|(0<<CS00);	//коэффициент делителя тактовой частоты /8 (3906.25 Гц, 256 микросекунд)
	//-----------------------------------------------------------------------------------------------------------
	TIMSK |=		//разрешение прерываний для трёх таймеров
	(0<<OCIE0)|
	(1<<TOIE0);		//по переполнению
	/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*/	//Таймер2
	TCCR2 =
	(0<<FOC2)|						//принудительное изменение вывода OC0 (работает только для режимов  Normal и CTC)
	(1<<WGM21)|(1<<WGM20)|			//режим работы таймера счетчика (Fast PWM)
	(1<<COM21)|(1<<COM20)|			//поведение вывода OC0 (00 вывод отключен)(10 очистка при совпадении)(11 установка при совпадении)
	(0<<CS22)|(0<<CS21)|(1<<CS00);	//коэффициент делителя тактовой частоты /1	(секунд)
	//-----------------------------------------------------------------------------------------------------------
	TIMSK |=		//разрешение прерываний для трёх таймеров
	(0<<OCIE2)|
	(0<<TOIE2);		//по переполнению
	/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*/	//Таймер1
	TCCR1A =
	(1<<COM1A1)|(1<<COM1A0)|		//поведение вывода OC1A при Fast PWM (10 очистка при совпадении) (11 установка при совпадении)
	(1<<COM1B1)|(1<<COM1B0)|		//поведение вывода OC1B (вывод отключен)
	(0<<FOC1A)|(0<<FOC1B)|			//принудительное изменение состояния выводов OC1(А/В)
	(1<<WGM11)|(1<<WGM10);			//режим работы таймера счетчика (Fast PWM 10bit)
	//-----------------------------------------------------------------------------------------------------------
	TCCR1B =
	(1<<ICNC1)|						//включение/отключение схемы подавления помех (отключено)
	(0<<ICES1)|						//активный фронт сигнала, то есть фронт по которому блок захвата будет выполнять сохранение счетного регистра (0 - спадающий фронт)
	(0<<WGM13)|(1<<WGM12)|			//режим работы таймера счетчика
	(1<<CS02)|(1<<CS01)|(1<<CS00);	//внешний источник тактирования пин T1
	//(0<<CS02)|(1<<CS01)|(1<<CS00);	//коэффициент делителя тактовой частоты /64
	//-----------------------------------------------------------------------------------------------------------
	TIMSK |=		//разрешение прерываний для трёх таймеров
	(0<<TICIE1)|
	(0<<OCIE1A)|	//прерывание по совпадению с OC1A
	(0<<OCIE1B)|
	(0<<TOIE1);
	/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*/	//Прерывания
	//			chipenable.ru/index.php/programming-avr/item/105-uchebnyy-kurs-ispolzovanie-vneshnih-preryvaniy-v-avr.html
	GICR =
	(1<<INT0)|		//Разрешить внешние прерывние на выводе INT0
	(0<<INT1)|		//Разрешить внешние прерывние на выводе INT1
	(0<<INT2)|		//Разрешить внешние прерывние на выводе INT2
	(0<<IVSEL)|		//
	(0<<IVCE);		//
	//-----------------------------------------------------------------------------------------------------------
	MCUCR |=
	(0<<ISC11)|(0<<ISC10)|	//Условие срабатывания прерывания INT1
	(1<<ISC01)|(1<<ISC00);	//Условие срабатывания прерывания INT0 (по нарастающему фронту 11) (по спадающему фронту 10)
	//-----------------------------------------------------------------------------------------------------------
	MCUCSR |= (0<<ISC2);		//Условие срабатывания прерывания INT2 (0 - по спадающему фронту, 1 - по нарастающему фронту)
	/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*/
	sei();		//разрешить прерывания
}
/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*/

/*==============================================================================================================*/
//*** Передача байта по UART ***//
void UART_Send(const uint8_t data)
{
	while(!(UCSRA & (1<<UDRE)));
	UDR = data;
}
/*==============================================================================================================*/
//*** Передача строки по UART ***//
void UART_SendStr(const char *str)
{
	//uint8_t data;
	while (*str){
		//data = *str++;
		while(!(UCSRA & (1<<UDRE)));
		UDR = *str++;
	}
}
/*==============================================================================================================*/
//*** Функция сравнения строк ***//
int StrCompare(const char *str1, const char *str2){
	uint8_t data1, data2;
	while(*str2){
		data1 = *str1++;
		data2 = *str2++;
		if(data1 != data2) {return 0;}
	}
	return 1;
}
/*==============================================================================================================*/
void clear_array(char *str)
{
	while (*str){
		*str++ = 0x00;
	}
}
/*==============================================================================================================*/
void coppy_array(char *str1, const char *str2)
{
	while (*str2){
		*str1++ = *str2++;
	}
}
/*==============================================================================================================*/
/*отправить и получить несколько байт данных по SPI*/
void SPI_MassiveRead(uint8_t num, uint8_t chip_select, uint8_t *data)
{
	PORTB &= ~(1<<chip_select);			//низкий уровень на линии выбора устройства
	while(num--){
		SPDR = *data;					//отправить байт по spi
		while(!(SPSR & (1<<SPIF)));		//выполнять цикл пока флаг прерываний SPIF от не установится в единицу
		*data++ = SPDR;
	}
	PORTB |= (1<<chip_select);			//высокий уровень на линии выбора устройства
}
/*==============================================================================================================*/
